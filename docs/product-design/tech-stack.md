# Yanshu 技术选型总结

## 一、技术选型概览

| 层级           | 技术选型           | 版本/规格 | 说明                   |
| -------------- | ------------------ | --------- | ---------------------- |
| **MCU 硬件**   | ESP32-S3           | -         | Wi-Fi + BT，I2S，PSRAM |
| **MCU 语言**   | Rust               | no_std    | 内存安全，状态机友好   |
| **MCU 框架**   | esp-rs / embassy   | -         | Rust 嵌入式生态        |
| **服务端语言** | Python             | 3.13+     | 模型生态丰富           |
| **Agent 框架** | Agno               | >= 2.3.22 | 已集成                 |
| **ASR**        | faster-whisper     | -         | 本地部署，低延迟       |
| **TTS**        | OpenAI TTS / Azure | -         | 流式合成               |
| **协议**       | 自定义二进制       | v1.0      | TCP 长连接             |
| **会话存储**   | Redis              | -         | 快速上下文存储         |
| **数据库**     | PostgreSQL         | -         | 历史记录（可选）       |
| **部署**       | Docker Compose     | -         | 容器化部署             |

## 二、MCU 终端技术栈

### 2.1 硬件平台

**选择: ESP32-S3**

**理由**:

- ✅ Wi-Fi + 蓝牙双模，满足网络需求
- ✅ I2S 音频接口，支持高质量音频
- ✅ PSRAM 支持，满足 buffer 需求
- ✅ Rust 生态成熟（esp-rs）
- ✅ 性价比高，开发板易得

**规格要求**:

- RAM: 512KB+ (PSRAM)
- Flash: 4MB+
- CPU: 240MHz (双核)

**替代方案**:

- STM32 + 外部 Wi-Fi 模块（更复杂，但更稳定）
- ESP32-C6（更便宜，但功能较少）

### 2.2 编程语言

**选择: Rust (no_std)**

**理由**:

- ✅ **内存安全**: 避免野指针、缓冲区溢出
- ✅ **状态机友好**: 类型系统天然支持 FSM
- ✅ **无 GC**: 实时性保证，适合嵌入式
- ✅ **性能**: 零成本抽象，接近 C 的性能
- ✅ **生态**: esp-rs 生态完善

**替代方案**:

- C/C++（传统选择，但安全性差）
- MicroPython（开发快，但性能差）

### 2.3 嵌入式框架

**选择: esp-rs / embassy**

**理由**:

- ✅ **esp-rs**: ESP32 官方 Rust 支持
- ✅ **embassy**: 异步运行时，适合网络 I/O
- ✅ 社区活跃，文档完善

**关键依赖**:

```toml
[dependencies]
esp-idf-sys = "0.36"
embassy-net = "0.1"
embassy-executor = "0.1"
```

### 2.4 音频处理

**选择: I2S HAL**

**理由**:

- ✅ 硬件 I2S 接口，低延迟
- ✅ 支持 16kHz, 16-bit, mono
- ✅ DMA 传输，不占用 CPU

**实现要点**:

- 使用 DMA 环形缓冲区
- 音频帧固定 20ms (640 bytes)
- 支持双缓冲，避免数据丢失

### 2.5 网络通信

**选择: TCP 长连接**

**理由**:

- ✅ 可靠传输（相比 UDP）
- ✅ 实现简单（相比 WebSocket）
- ✅ 低开销（相比 HTTP）

**实现**:

- 使用 `embassy-net` 或 `esp-idf-sys` 的 TCP 客户端
- 自动重连机制（指数退避）
- 心跳保活（10 秒间隔）

## 三、服务端技术栈

### 3.1 编程语言

**选择: Python**

**理由**:

- ✅ **模型生态**: Whisper、TTS 模型主要在 Python
- ✅ **Agent 框架**: Agno 是 Python
- ✅ **开发效率**: 快速迭代，易于调试
- ✅ **部署简单**: Docker 容器化

**版本要求**: Python 3.13+

### 3.2 Agent 框架

**选择: Agno**

**理由**:

- ✅ 已集成到项目
- ✅ 支持 Tool Calling
- ✅ 流式响应
- ✅ 易于扩展

**版本**: >= 2.3.22

### 3.3 ASR (语音识别)

**选择: faster-whisper**

**理由**:

- ✅ **本地部署**: 无需云端，保护隐私
- ✅ **低延迟**: 流式识别，首字 < 300ms
- ✅ **高准确率**: 基于 Whisper，准确率高
- ✅ **多语言**: 支持中文等多种语言

**替代方案**:

- OpenAI Whisper API（需要网络，有延迟）
- Azure Speech（企业级，需要网络）
- 本地小模型（准确率较低）

**实现要点**:

- 使用流式 API
- 支持 VAD（可选，服务端做）
- 模型选择：base 或 small（平衡速度和准确率）

### 3.4 TTS (文本转语音)

**选择: OpenAI TTS / Azure TTS**

**理由**:

- ✅ **流式合成**: 低延迟首帧
- ✅ **音质好**: 自然流畅
- ✅ **多语言**: 支持中文

**替代方案**:

- Piper（本地部署，音质稍差）
- Coqui TTS（开源，需要训练）
- Azure Neural TTS（企业级）

**实现要点**:

- 必须支持流式 API
- 首帧延迟 < 300ms
- 支持打断（收到 INTERRUPT 立即停止）

### 3.5 协议网关

**选择: Python (FastAPI/WebSocket) 或 Go**

**Python 方案**:

- **框架**: FastAPI + WebSocket（或 raw TCP）
- **理由**: 与 Agent 服务集成简单
- **实现**: `asyncio` 异步处理

**Go 方案**:

- **框架**: gorilla/websocket 或 net/http
- **理由**: 性能更好，适合高并发
- **实现**: goroutine 并发处理

**推荐**: 第一版用 Python，后续如果性能瓶颈再考虑 Go。

### 3.6 会话存储

**选择: Redis**

**理由**:

- ✅ **快速**: 内存存储，毫秒级响应
- ✅ **适合**: 会话上下文需要快速读写
- ✅ **TTL**: 自动过期，无需手动清理

**数据结构**:

```python
# Key: session:{session_id}
# Value: JSON
{
    "user_id": "user_xxx",
    "context": [...],
    "created_at": "...",
    "last_active": "..."
}
# TTL: 3600 秒（1小时）
```

**替代方案**:

- 内存字典（单机，不支持分布式）
- PostgreSQL（持久化，但较慢）

### 3.7 数据库（可选）

**选择: PostgreSQL**

**理由**:

- ✅ **持久化**: 历史记录长期存储
- ✅ **查询能力**: 支持复杂查询
- ✅ **成熟**: 生产环境验证

**用途**:

- 用户历史对话记录
- 设备信息
- 统计数据

**注意**: MVP 阶段可以不用，后续添加。

## 四、通信协议

### 4.1 传输层

**选择: TCP 长连接**

**理由**:

- ✅ **可靠**: 保证数据不丢失
- ✅ **简单**: 实现简单，无需复杂协议栈
- ✅ **低延迟**: 相比 HTTP，无握手开销

**替代方案**:

- WebSocket（更复杂，但浏览器友好）
- gRPC（功能强大，但 MCU 端实现复杂）
- MQTT（适合 IoT，但延迟较高）

### 4.2 应用层协议

**选择: 自定义二进制协议**

**理由**:

- ✅ **低延迟**: 无 JSON 解析开销
- ✅ **高效**: 固定帧长，易于 buffer 管理
- ✅ **简单**: MCU 端实现简单
- ✅ **可控**: 完全控制协议格式

**协议特点**:

- 固定帧头（3 bytes: TYPE + LEN）
- 音频帧固定长度（640 bytes）
- 明确的类型标识

**替代方案**:

- JSON over TCP（简单，但解析开销大）
- Protobuf（高效，但需要额外依赖）
- MessagePack（二进制，但不如自定义协议灵活）

## 五、部署方案

### 5.1 容器化

**选择: Docker + Docker Compose**

**理由**:

- ✅ **简单**: 一键部署所有服务
- ✅ **隔离**: 服务之间互不干扰
- ✅ **可移植**: 任何支持 Docker 的环境都能运行

**服务拆分**:

```yaml
services:
  gateway: # 协议网关
  asr-service: # ASR 服务
  agent-service: # Agent 服务
  tts-service: # TTS 服务
  redis: # 会话存储
  postgres: # 数据库（可选）
```

### 5.2 边缘设备

**选择: Raspberry Pi 5 或 Intel N100 mini PC**

**Raspberry Pi 5**:

- ✅ 体积小，功耗低
- ✅ 社区支持好
- ⚠️ 性能有限（4 核 ARM）

**Intel N100 mini PC**:

- ✅ 性能强（x86）
- ✅ 兼容性好
- ⚠️ 功耗稍高，价格稍贵

**推荐**: MVP 用 Raspberry Pi 5，生产环境用 Intel N100。

### 5.3 操作系统

**选择: Ubuntu Server 22.04 LTS**

**理由**:

- ✅ **稳定**: LTS 版本，长期支持
- ✅ **兼容**: Docker、Python 生态完善
- ✅ **文档**: 文档丰富，问题易解决

## 六、开发工具

### 6.1 包管理

**Python**: uv（推荐）或 pip
**Rust**: cargo

### 6.2 代码质量

**Python**:

- **格式化**: black
- ** lint**: ruff
- **类型检查**: mypy

**Rust**:

- **格式化**: rustfmt
- **lint**: clippy

### 6.3 测试

**Python**: pytest
**Rust**: cargo test

### 6.4 调试

**MCU**:

- 串口日志
- GDB（通过 OpenOCD）

**服务端**:

- 日志系统（structlog）
- 远程调试（VS Code Remote）

## 七、关键技术决策总结

### 7.1 为什么 MCU 不做 ASR？

- ❌ **算力不足**: MCU 无法运行 Whisper
- ❌ **功耗高**: 本地 ASR 功耗大
- ✅ **灵活性**: 服务端可以快速升级模型
- ✅ **成本**: 服务端算力成本更低

### 7.2 为什么选择 Rust for MCU？

- ✅ **内存安全**: 避免崩溃
- ✅ **状态机友好**: 类型系统支持 FSM
- ✅ **无 GC**: 实时性保证
- ✅ **生态成熟**: esp-rs 支持好

### 7.3 为什么服务端用 Python？

- ✅ **模型生态**: Whisper、TTS 主要在 Python
- ✅ **Agent 框架**: Agno 是 Python
- ✅ **开发效率**: 快速迭代
- ✅ **部署简单**: Docker 容器化

### 7.4 为什么自定义二进制协议？

- ✅ **低延迟**: 无 JSON 解析开销
- ✅ **高效**: 固定帧长，易于管理
- ✅ **简单**: MCU 端实现简单
- ✅ **可控**: 完全控制协议格式

## 八、后续优化方向

1. **本地模型**: 在边缘设备部署小模型（如 Qwen2.5-1.5B）
2. **唤醒词**: 集成唤醒词检测（如 Porcupine）
3. **多设备**: 支持一个服务端服务多个 MCU
4. **离线模式**: 完全本地化，不依赖云端
5. **蓝牙集成**: MCU 直接连接蓝牙音箱（HFP/A2DP）

---

**文档版本**: v1.0  
**最后更新**: 2025-01-22  
**维护者**: Yanshu Team
